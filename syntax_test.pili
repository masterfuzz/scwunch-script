
function test
	'key': 'value'
	1, 2, 3: 'one-three'
	['key']: 'another value'  # okay, I admit this one is syntactically very similar to the one below.
	a = 1
	[a]: 'block?'  # this one is ambiguous
	[num x]: x + 1  # interpreted as block... because the key is recognized syntactically as parameters
	[num x]:
        return x + 1
    [a, b, c]:
        return str[a] + str[b] + str[c]
	foo[args]: 'one line function'
	print foo[1]

print test['key']
print test[1, 2, 3]
print test[1]
print test[1000]
print test[2, '-', 4]
print test.a2


```
node, node
OpExpr(,), node
List, node
Params, block
OpExpr(.), block
# other combinations impossible in AST
```


# I guess I should distinguish between key-value pairs and param-block pairs by the use of square brackets.
# no, changed my mind again: I will distinguish it primarily by the one-line or multi-line distinction.




function Test
	local_var = 5
	slot prop int = 5

	str[Test self]:
		return "Test"
	str[]:
		return "Test"
	.str[]:
		return "Test"

	foo[Test self, any arg]:
		do stuff

	foo[any arg]:
		do stuff

	.foo[any arg]:
		do stuff

	bar[Test(prop=int>0) self]:
		return "positive prop"

	bar[Test(prop=int<0) self]:
		return "negative prop"

test = new[Table]

if "foo" == "bar"
	op = test.bar
else
	op = test.foo

return op[other, args]

if "foo" == "bar"
	op = Test.bar
else
	op = Test.foo

return op[test, other, args]

```
Okay, I've got another conundrum: defining methods.  The issues is this: if I define methods within the scope of the table, then the function is not available â€” even with UFCS.  So how do we solve this?  Here are the possibilities:
 1. Promote functions defined within tables to the scope of table.env.
	- this is confusingly inconsistent with defining simple variable names in the table that stay in the table context.
	- in practice, not so bad if the names only ever refer to functions... but what if a method name clashes with the name of a global variable for another record?  And what if that global variable gets reassigned???
		- what about defining in *both* scopes?  That's too wierd.
	- but this is the only way I don't lose the ability to call foo[test] (in addition to test.foo[])
	- which becomes a little more important for methods that want a different pattern for the first argument (eg, `Test|Other` or `Test(prop=3)`)
 2. Allow the dot operator to select a variable/method AND also pass the record as a first argument
	- or the dot operator selects the method, and returns a partial function with the caller filled in
	- what about static methods?  or slot functions?
 3. Allow the dot operator to select a variable/method, then the self keyword references the function caller (ie, the record preceding the dot)
	- I think this is best option for the following reasons:
		- self is already a key word for opt options
		- won't conflict with other arguments in case of static methods
		- can be overwritten in the case of different patterns other than table
		- hold on, that's only true if I *also* adopt solution 2...

Solution (similar to #2):
	- expression test.foo evaluates to a new Function record that is a partially applied function of the method
	- but expression test.foo[args...] does the following:
		- look for slot foo
		- look for foo in Test
			- if variable, return that
			- if method, call it on [args...] with self=test
		- look for foo in current scope
			- if function, call with self=test
	- dot methods like .foo[args...] are simply a short-hand for foo[Test self, args...]
```








