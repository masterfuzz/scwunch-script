# var = "hi"
# print self.var = "hello"
# print var
# print self.var
# exit


# basic values are numbers and strings
print "string literals can use double quotes"
print 'or single quotes'
print `or backticks`
print ''

# escape characters are recognized in single or double quoted strings, but in backtick strings are interpreted literally
print "escape characters like \t(tab) and \n(newline) are recognized in"
print 'both \'single quote\' and "double quote" strings'
print `backquote strings have no escape characters; "\n" just becomes "\n"`
print ``double-backticked strings can have `backticks` inside them``
print ''

print `string interpolation using {expression} also works`
print '1 + 2 = {1 + 2}'
CAN = 'can'
print 'Can you nest string interpolation? {'Yes, you {CAN}' if 1 == 1 else 'nope'}'
print ''
print 'next is "settings.base = \'h\'"'
settings.base = 'h'
# pili fluidly and automatically converts between booleans, integers, and rational numbers,
# depending on what operators are applied to them
# floats only appear if a function explicitly returns a float (like the float function) or float literals
my_bool = 'two' == 'two'
my_int = my_bool * 10
my_ratio = my_int / 4
print '10/4 = {my_ratio} (type: {type[my_ratio]})'
print "10/4 * 2 = {my_ratio*2} (type: {type[my_ratio*2]})"
my_float = 0.55400
print my_float

# by the way, all numbers in pili used to be heximal (base-six).  To input decimal numbers, use a 'd' suffix.  To output decimal numbers, convert using the string function
print '9d = {9d}'
print 'str[20, 10d] = {str[20, 10d]}'
print ''

# the default base is stored in the pili.settings module
print "current base: " + settings.base
print "the base is a letter representing (from binary to decimal): 'btqphsond'"
# ... but then it was decided that heximal was too wierd, and so we switched back to decimal
# set the default base like this:
settings.base = 'd'
print "Just changed the base back to decimal.  See?  5 + 4 = {5+4}"
print ''

# How do you define function?
greeting[str name]:
    return 'Hello ' + name

# the function must have an identifier (usually a simple name like 'greeting')
# the function must have a set of 0 or more parameters
# each parameter has a pattern and (optionally) a name to bind to when matched.
# in this case, the pattern is the prototype 'str' and the name is 'name'
# this function happens to only need one line — it could be written like this:
greeting[str name]: 'Hello ' + name

print greeting["Ryan"]

# of course, functions may have multiple options — that's kinda Pili's thing.  They can be added simply by redefining the function again with different parameters

greeting[str name, int times]:
    return 'Hi {name}! ' * times

# the actual code that runs depends on the arguments passed to the function — the match is automatically detected

print "greeting['Bob'] -> " + greeting['Bob']
print "greeting['Bob', 3] -> " + greeting['Bob', 3]


# patterns can get pretty sophisticated if you need them to.  And parameters can have quantifers like regex
greeting[str name, int<0 times]:
    return "Goodbye {name}. " * -times
greeting[str names+]:
    greets = []
    for name in names
        push[greets, 'Hi {name}']
        # greets.push['Hi {name}']
    if not has 'times'
        times = 1
    return greets.join[', '] * times

print "greeting['Fred', -2] -> " + greeting['Fred', -2]
print "greeting['Larry', 'Matilda'] -> " + greeting['Larry', 'Matilda']
print ''

# You just saw the "has" operator above; it checks for the existence of an option (by name or pattern or by list of arguments)

print 'greeting has ["any random name"] -> {greeting has ["any random name", 444]}'
print 'greeting has "name" -> {greeting has "name"}'
print 'greeting has "Ryan" -> {greeting has "Ryan"}'
print 'has "greeting" ->  {has "greeting"}'
print ''

# How does this matching work?  There are three main classes of patterns:
# 1. value patterns
# 2. prototype patterns
# 3. union patterns
# value patterns are created when you use the = operator to assign a value to a value pattern.  Eg
print "Value Patterns"
greeting[1] = "One"
greeting["one"] = 1
greeting[1] ??= "one"
print 'greeting[1] => ' + greeting[1]
print 'greeting["one"] => {greeting["one"]}'
# notice how that second pattern *overrides* the very first pattern [str name] that we put on greeting.  Value patterns generally take precedence over prototype patterns
print "value patterns are mostly just used as keys in dictionary-like options; they either match a value or they don't — not that exciting so let's move on to prototype patterns."

print "\nPrototype Patterns"
# prototype patterns are interpreted from values when used as parameters, like [str name] above
# prototype matching is also used by the MATCH ~ operator
print '-33 is int => {-33 is int}'
print '0.43 ~ float and 0.43 ~ num and -33 ~ num => {0.43 ~ float and 0.43 ~ num and -33 ~ num}'
print '0.43 ~ str => {0.43 ~ str}'
print '0.43 !~ str => {0.43 !~ str}'
# union patterns match if any of the sub-patterns match
print "'hello' ~ num|str => {'hello' ~ num|str}"
neg_float_or_pos_int = float < 0 | int > 0

print "Indexing and slicing..."
ls = (1, 2, 3, 4, 5)
print ls[1]
print ls[2]
print ls[3]
print ls[4]
print ls[-1]
print 'two-index slices'
print ls[0,1]
print ls[1,0]
print ls[2,-2]
print ls[5,0]
print ls[-2,0]
print "three-index slices"
print ls[1,0,1]
print ls[0,0,2]
print ls[1,0,2]
print ls[4,1,-1]
print ls[0,0,-1]

print "for n in [-1, 0 , 1, -0.3, 0.0, 0.3]"
for n in [-1, 0 , 1, -0.3, 0.0, 0.3]
    print "{' ' * (10-len[n.str])}{n} ~ float < 0 | int > 0 => {n ~ neg_float_or_pos_int}"
print "5 ~ float | int > 4 => {5 ~ float | int > 4}"
print "-0.3 ~ float | int > 4 => {-0.3 ~ float | int > 4}"
# these are just some built-in types.  We can create our own too
print 5 ~ float | int > 4
print 5 ~ int > 4 | float


# Some funky operators
print "The `has` and `~` operators are just some of the funky operators in Pili."
print "There is also `??`, `.?`, and `..`."
print "some_null_value = blank; some_null_value ?? 0 ?? 1 => {some_null_value = blank; some_null_value ?? 0 ?? 1}"
print greeting['one']
print greeting.?name ?? greeting.?nlljlasd ?? greeting.?[2451] ?? 'none of those optinos were found\n'

# the swizzle operator `..` is fun.  It acts like a dot operator distributed over every element of an iterable
print "my_list = {my_list = [-1, -2, 0 ,1 ,2, ]}"
print "my_list..abs => {my_list..abs}"


# Tables
# table Animal
#     species <str> = "human"
#     alive <bool> = True
#     _slices
#     slices <set[Slice]>:
#         filters = self.get_filter_slices
#         return filters + self._slices
#     [str species?] -> Animal:
#         return Animal[species]
#     .len:
#         return len[slices]
#
#
# slice Dog of Animal
#     species <"dog"> = "dog"
#     .bark:
#         print "bowowow"




print "\n\n**************************"
# There are no classes in Pili, just prototypes.  Objects are called "Functions" and each function also acts as a prototype.
# When a function lacks a return statement, it will return an "instance" of itself.
# A newly created function has as it's prototype the function that was used to create it.
# A function literal value has no prototype
# There are two ways to create class-like inheritance


# Animal =
#     []:
#         blank
#     species = blank
#     alive = "I'm alive."
#     "make_sound" : print self.sound
#     print_sound[]:
#         print self.sound
#
# a = Animal[]
# # print a.species
# print a.type
#
# Dog =
#     inherit Animal
#     []:
#         none
#     bark: print "Bark!"
#     sound = 'bark sound!'
#     species = 'canis lupus'
#
# d = Dog[]
# print d.species
# print d.alive
# d.make_sound
# # d.print_sound[],,
# print d.type
# print d.type.type
#
#
# print "\n\n************************************"
# Factory =
#     []:
#         Factory.factory_count += 1
#         Animal[str species]:
#             []:
#                 Factory.species_count += 1
#             alive = "I'm alive."
#             greet:
#                 return "Hi, I'm a {self.species}"
#     factory_count = 0
#     species_count = 0
#
# f = Factory[]
# print Factory.factory_count
# print f.factory_count
# off = f[]
# print type[off]




print "Some funky operators include:  .., ??, ~, "
print "next: demo classes/prototyping and dot-options"
print "aliases... := ..."
print "Pili also does closures similarly to python"
# but not exactly the same; if a variable is undefined at runtime, it will be excluded from the closure
x = "global x"
closure_demo[]:
    z = "outer z"
    donky[]:
        inner[any y]:
            return x, y, z

        if USE_DONKY_Z
            z = "donky z"
        return inner

    chonky[]:
        x = "chonky x"
        f = donky[]
        return f

    f = chonky[]
    return f["y arg"]

USE_DONKY_Z = true and 0
print closure_demo[]


print "\n\n************************************************"
# the exit command is not necessary, but without it, the script will return the running function, which is awkwardly printed as root.main

trait Animal
    slot species str?
    slot alive bool = true
    slot sound str = ""
    formula make_sound blank :
        print self.sound


table Dog @Animal
    slot name str = ""
    slot length num
    slot array list:
        return []
    formula bark str:
        return "Helo, my name is {self.name}!"
    formula print_bark:
        print self.bark
    debug opt [int n]:
        return self.array[n]
    opt [int i, int j]:
        return self.array[i, j]

    [str name, int length, list array]:
        return Dog.new[name, length, array, 'Dog', true, 'bark']

    .call[]:
        return

    .str[]:
        return

    .bool[]:
        return

#     .'+'[]:
#         return
#
#     Op['+'][Dog d1, Dog d2]:
#         return
#
#     .Op['+'][any other]:
#         return
#
#     .add[any other]:
#         return
#
#     .'.'[]:
#         return

    # .module.add[]:
    #     return
    #
    # module.add[Dog d1, Dog d2]:
    #     return

    # dot-option
    .eat[any food]:
        del(food)
        self.full = True


rover = Dog['Rover', 137, [1,2,3]]
boulder = Dog['Boulder', 232, ['a', 'b', 'c'], 'Big Dog', sound='BARK']

print rover.name
print rover.length
print rover.array
print rover.species
print rover.alive
print rover.sound
print debug rover[-1]
rover.make_sound
print boulder.name
print boulder.length
print boulder.array
print boulder.species
print "Boulder's Sound: "+  boulder.sound
boulder.make_sound
print "OY"
other = Dog[name='Boulder', 232, sound='B-b-b bark BaRk!']  #, !big]
print "OY"
print 'other sound is ' + other.sound
other.make_sound

# fn sum[num a+, DogType]


trait Details
    formula description str:
        return "{self.title}, released in {self.release_year}, is a {self.genre} movie directed by {self.director}."
    formula years_since_release int:
        return 2020 - self.release_year

table Movie @Details
    slot title str = ""
    slot director str = ""
    slot release_year int>0
    slot genre str
    [str title, str director, int release_year, str genre]:
        return Movie.new[title, director, release_year, genre]

    setter description[any val]:
        self.genre = str[val]

table TokenType
    slot name str
    [str t]:
        return TokenType.new[t]

table TokenTypeEnum
    slot Unkown TokenType = TokenType['?']
    slot Operator TokenType = TokenType['op']

TokenType = TokenTypeEnum[]

# Node[!argset, 2,3,4]

# trait Node
#     slot pos tuple(int, int) = (-1, -1)
#     slot type TokenType = TokenType.Unknown








# ls`['3 .. 1', -1]






















