from fractions import Fraction
from Env import *
from Syntax import Block, FunctionLiteral
from Expressions import Expression
from typing import TypeVar, Generic

FlexiPatt = Pattern | Parameter | Matcher | str
PyFunction = type(lambda : None)

class FunctionRecordPrototype:
    name: str
    # mro: tuple[Function, ...]
    env: Record
    # caller: Function | None  # self
    options: list[Option]
    # named_options: dict[str, Option]
    hashed_options: dict[tuple[Record, ...], Option]
    # args: list[Option]
    block: Block
    # exec: any
    # return_type: Pattern
    # return_value: Record | None
    # value: val_types
    is_null: bool
    def add_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    def remove_option(self, pattern: FlexiPatt): ...
    def assign_option(self, pattern: Pattern, resolution: opt_resolution = None) -> Option: ...
    def index_of(self, key: list[Function]) -> int | None: ...
    def select_and_bind(self, key: list[Record] | tuple[Record], walk_prototype_chain=True, ascend_env=False) \
            -> tuple[Option, dict[str, Record]]: ...
    def select_by_pattern(self, patt, default=None, ascend_env=False) -> Option | None: ...
    def select_by_name(self, name: str, ascend_env=True) -> Option | None: ...
    def select_by_value(self, value: tuple[Record, ...], ascend_env=True) -> Option | None: ...
    def call(self, *key: Record, copy_option=True, ascend=False) -> Record: ...
    def deref(self, name: str, ascend_env=True) -> Function: ...
    def init(self, pattern: Pattern, key: list[Record], parent: Function = None, copy=True) -> Function: ...
    def instanceof(self, prototype: Function) -> float: ...
    def clone(self) -> Function: ...

class Prototype(FunctionRecordPrototype):
    """ essentially just container to hold the options of tables, a proxy for methods """
    table: Table
    def __init__(self, table: Table): ...

class Record(FunctionRecordPrototype):
    table: Table
    _filter_slices: set[FilterSlice] | None
    _non_filter_slices: set[Slice]
    slices: set[Slice]
    data: list[Record]
    key: Record
    index: int | None
    truthy: bool = True
    def __init__(self, table: Table, **data: Record): ...
    def get(self, name: str): ...
    def get_by_index(self, index: int): ...
    def set(self, name: str, value: Record): ...
    def set_by_index(self, index: int, value: Record): ...
    def update_slices(self, *slices: FilterSlice): ...
    def hashable(self) -> bool: ...


T = TypeVar('T', None, bool, int, Fraction, float, str, tuple, frozenset)
A = TypeVar('A')
class PyValue(Record, Generic[T]):
    value: T
    def __init__(self, table: Table, value: T): ...

# class PyValue(Record):
#     value: None | bool | int | Fraction | float | str | tuple | frozenset
#     def __init__(self, table: Table, value: None | bool | int | Fraction | float | str | tuple | frozenset): ...

class PyObj(Record, Generic[A]):
    obj: any
    def __init__(self, obj): ...

def py_value(value: None | bool | int | Fraction | float | str | tuple | frozenset) -> PyValue: ...
def piliize(value: any) -> Record: ...


class Table(Record):
    fields: list[Field]
    field_ids: dict[str, int]
    records: list[Record] | dict[Record, Record] | set[Record] | None
    slices: set[Slice]
    prototype: Prototype  # contains all the heritable slots, formulae, and options
    def __init__(self, *field_tuple: Field, **fields: Matcher): ...
    def __getitem__(self, key: Record) -> Record | None: ...
    def __setitem__(self, key: Record, value: Record): ...
    def __contains__(self, item: Record): ...
    def upsert_field(self, field: Field): ...
    def add_record(self, record=None, **data): ...
    def _add_record(self, record: Record): ...

class ListTable(Table):
    records: list[Record]
    def __init__(self, *field_tuple, **fields): ...
    def __getitem__(self, key: PyValue[int]): ...

class MetaTable(ListTable):
    def __init__(self): ...


class DictTable(Table):
    records: dict[Record, Record]
    key_field: int
    def __init__(self, key_field: int = 0, *field_tuple, **fields): ...

class SetTable(Table):
    records: set[Record]
    def __init__(self, *field_tuple, **fields): ...

class VirtTable(SetTable):
    records = None
    def __init__(self, *field_tuple, **fields): ...

class Slice(Table):
    parent: Table
    def __init__(self, parent: Table): ...

class FilterSlice(Slice, VirtTable):
    filter: Function | PyFunction
    def __init__(self, parent: Table, filter: Function | PyFunction): ...

class ListSlice(Slice, ListTable): ...

class DictSlice(Slice, DictTable): ...

class SetSlice(Slice, SetTable): ...

class Field(Record):
    name: str
    type: Matcher
    setter: Function = None
    def __init__(self, name: str, type: Matcher, default: Function | None = py_value(None),
                 formula: Function = py_value(None), setter: Function = None): ...

class Slot(Field):
    default: Function
    def __init__(self, name: str, type: Matcher, default: Function = None, setter: Function = None): ...

class Formula(Field):
    formula: Function
    def __init__(self, name: str, type: Matcher, formula: Function, setter: Function = None): ...

class Matcher:
    name: str | None
    inverse: bool = False
    guard: Function | PyFunction = None
    def __init__(self, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def match_score(self, arg: Record) -> int | float: ...
    def call_guard(self, arg: Record) -> bool: ...

class TableMatcher(Matcher):
    table: Table
    def __init__(self, table: Table, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class SliceMatcher(Matcher):
    slices: tuple[Slice, ...]
    def __init__(self, *slices: Slice, name=None, guard=None, inverse=False): ...
class ValueMatcher(Matcher):
    value: Record
    def __init__(self, value: Record, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Union(Matcher):
    matchers: frozenset[Matcher]
    # params: set[Parameter]  # this would make it more powerful, but not worth it for the added complexity
    # examples;
        # int+ | str
        # list[int] | int+
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Intersection(Matcher):
    matchers: frozenset[Matcher]
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class AnyMatcher(Matcher):
    def __eq__(self, other): ...
    def __hash__(self): ...

class Parameter:
    matcher: Matcher | None
    name: str | None
    quantifier: str  #  "+" | "*" | "?" | ""
    count: tuple[int, int | float]
    optional: bool
    multi: bool

    def __init__(self, matcher: Matcher | None, name: str = None, quantifier: str = ""): ...
    def try_get_matchers(self) -> tuple[Matcher, ...] | list[Matcher]: ...
    def match_score(self, value: Record) -> int | float: ...

class UnionParam(Parameter):
    parameters: list[Parameter]
    def __init__(self, *parameters: Parameter, name: str = None, quantifier: str = ""): ...

class AnyParam(Parameter):
    pass

def copy_bindings(saves: dict[str, Function]) -> dict[str, Function]: ...

class Pattern(Record):
    parameters: tuple[Parameter]
    def __init__(self, *parameters: Parameter): ...
    def match_score(self, arg: Record) -> int | float: ...
    def min_len(self) -> int: ...
    def max_len(self) -> int | float: ...
    # def match_zip_recursive(self, args: list = None, i_inst: int = 0, i_arg: int = 0, score: float = 0, sub_score: float = 0, saves: dict[str, Record] = None) \
    #         -> 0 | tuple[int|float, dict[str, Record]]: ...
    def match_zip_recursive(self, state: MatchState) -> 0 | tuple[int|float, dict[str, Record]]: ...
    def match_zip(self, args: list[Record] = None) -> tuple[float|int, dict[str, Record]] | 0: ...
    def try_get_params(self) -> tuple[Parameter, ...]: ...
    def try_get_matchers(self) -> tuple[Matcher, ...] | list[Matcher]: ...
    def __len__(self): ...
    def __getitem__(self, item): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class MatchState:
    parameters: list[Parameter]
    args: list[Record]
    i_param: int
    i_arg: int
    score: int | float
    param_score: int | float
    bindings: dict[str, Record | list[Record]]
    def __init__(self, parameters, args, i_param=0, i_arg=0, score=0, param_score=0, bindings=None): ...

# class SubPattern:
#     patterns: tuple[Pattern, ...]
#     def __init__(self, *patterns: Pattern): ...
#
# class UnionPattern(SubPattern): ...
#
# class IntersectionPattern(SubPattern): ...

def patternize(value: Record) -> Pattern: ...

class FuncBlock_DEPRECATED:
    """
    trying to replace this with CodeBlock and Closure
    """
    exprs: list[Expression]
    env: Record
    native: PyFunction
    def __init__(self, block: Block | FunctionLiteral | PyFunction, env: Function = None): ...
    def make_function(self, options: dict[Pattern, opt_resolution], type: Function, caller: Function = None) -> Function: ...
    def execute(self, args: list[Function] = None, scope: Function = None, dot_option: bool = False) -> Function: ...

class CodeBlock:
    exprs: list[Expression]
    scope: Closure | None
    native: PyFunction
    def __init__(self, block: Block | FunctionLiteral | PyFunction): ...
    def execute(self, args: tuple[Record, ...] = None, caller: Record = None, bindings: dict[str, Record] = None): ...

class Closure:
    names: dict[str, Record]
    code_block: CodeBlock
    scope: Closure
    args: tuple[Record, ...]
    caller: Record
    return_value: Record = None
    def __init__(self, code_block: CodeBlock | None, args: tuple[Record, ...] = None, caller: Record = None, bindings: dict[str, Record] = None): ...

class TopNamespace(Closure):
    code_block = None
    scope = None
    args = None
    caller = None
    def __init__(self, bindings: dict[str, Record]): ...

opt_resolution = Function | CodeBlock | PyFunction | None
class Option(Record):
    pattern: Pattern
    resolution: opt_resolution
    value: Record
    block: CodeBlock
    fn: PyFunction
    alias: Option
    dot_option: bool
    def __init__(self, pattern: FlexiPatt, resolution: opt_resolution = None): ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def nullify(self): ...
    def assign(self, val_or_block: opt_resolution): ...
    def resolve(self, args: tuple[Record, ...], caller: FunctionRecordPrototype = None, bindings: dict[str|int, Record] = None) -> Record: ...

class Function(Record):
    def __init__(self,
                 options: dict[FlexiPatt, opt_resolution] = None,
                 args: dict[FlexiPatt, opt_resolution] = None,
                 type: Table = None,
                 env: Function = None,
                 # value: Value = None,
                 # is_null=False,
                 caller: Function = None,
                 name: str = None
                 ): ...

class Operator:
    text: str
    prefix: int | None
    postfix: int | None
    binop: int | None
    ternary: str | None
    associativity: str
    fn: Function
    chainable: bool
    static: bool | PyFunction
    def __init__(self, text, fn:Function=None, prefix:int=None, postfix:int=None, binop:int=None,
                 ternary:str=None, associativity='left', chainable:bool=False, static=False): ...
    def eval_args(self, lhs, rhs) -> list[Record]: ...
