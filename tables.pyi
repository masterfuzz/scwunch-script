from fractions import Fraction
from Env import *
from Syntax import Block
from Expressions import Expression
from typing import TypeVar, Generic

FlexiPatt = Pattern | Parameter | Matcher | str
PyFunction = type(lambda : None)


class OptionCatalog:
    """
    An OptionCatalog object has is created by deduplicating the options from a sequence of Traits, and categorizing them
    into a list of options and a hash-map of options.  The OptionCatalog is responsible for selecting options from Args.
    """
    op_list: list[Option]
    op_map: dict[Args, Option]
    # noinspection PyDefaultArgument
    def __init__(self, options: dict[FlexiPatt, opt_resolution] = {}, *traits: Trait): ...
    def assign_option(self, pattern: FlexiPatt | Option, resolution: opt_resolution = None, *, no_clobber=False) -> Option: ...
    def remove_option(self, pattern: FlexiPatt): ...
    def select_and_bind(self, key: list[Record] | tuple[Record] | Args, walk_prototype_chain=True, ascend_env=False) \
            -> tuple[Option, dict[str, Record]] | tuple[None, None]: ...
    def select_by_pattern(self, patt, default=None, ascend_env=False) -> Option | None: ...

class Record:
    name: str | None
    table: Table
    data: list[Record]
    key: Record
    index: int | None
    truthy: bool = True
    mro: tuple[Trait, ...]
    def __init__(self, table, *data_tuple: Record, **data_dict: Record): ...
    def get(self, name: str, *default) -> Record: ...
    # def get_by_index(self, index: int) -> Record: ...
    def set(self, name: str, value: Record): ...
    # def set_by_index(self, index: int, value: Record): ...
    def call(self, *args: Record, flags: set[Record] = None, **kwargs: Record) -> Record: ...
    def __call__(self, args: Args): ...
    def select(self, args: Args) -> tuple[Option | None, dict | None]: ...
    def hashable(self) -> bool: ...
    def to_string(self) -> PyValue[str]: ...
    def __index__(self) -> int: ...


T = TypeVar('T', None, bool, int, Fraction, float, str, tuple, frozenset, set, list)
class PyValue(Record, Generic[T]):
    value: T
    def __init__(self, table: Table, value: T): ...

A = TypeVar('A')
class PyObj(Record, Generic[A]):
    obj: any
    def __init__(self, obj): ...

List = py_value

def py_value(value: T) -> PyValue: ...
def piliize(value: any) -> Record: ...

class Function(Record, OptionCatalog):
    slot_dict: dict[str, Record]
    formula_dict: dict[str, Function]
    setter_dict: dict[str, Function]
    def __init__(self,
                 options: dict[FlexiPatt, opt_resolution] = None,
                 *fields: Field,
                 name: str = None,
                 table_name: str = 'Function',
                 traits: tuple[Trait, ...] = ()): ...
    def update_field(self, field: Field): ...
    def get(self, name: str, *default): ...
    def set(self, name: str, value: Record): ...
    def select(self, args): ...
    # def add_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    # def assign_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...

class Trait(Function):
    options: list[Option]
    # hashed_options: dict[tuple[Record, ...], Option]
    # field_ids: dict[str, int]
    fields: list[Field]
    # trait: Trait | None = None  # its own trait, since traits can be treated like functions
    # noinspection PyDefaultArgument
    def __init__(self, options: dict[FlexiPatt, opt_resolution] = {},
                 *fields: Field,
                 name: str = None,
                 fn_options: dict[FlexiPatt, opt_resolution] = {},
                 fn_fields: list[Field] = []): ... #, own_trait: Trait = None): ...
    # def get_field(self, rec: Record, index: int): ...
    # def set_field(self, rec: Record, index: int, value: Record): ...
    def upsert_field(self, field: Field): ...
    # def add_own_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    # def select_by_value(self, value: tuple[Record, ...], ascend_env=True) -> Option | None: ...

class Table(Function):
    records: list[Record] | dict[Record, Record] | set[Record] | None
    traits: tuple[Trait, ...]  # the traits to be used by instances.  traits[0] is defined in the table body block
    catalog: OptionCatalog
    getters: dict[str, int | Function]
    setters: dict[str, int | Function]
    defaults: tuple[Function, ...]  # this is for instantiation of Records
    trait: Trait  # property that points to the first trait in traits
    # noinspection PyDefaultArgument
    def __init__(self, *traits: Trait,
                 name: str = None,
                 fn_options: dict[FlexiPatt, opt_resolution] = {},
                 fn_fields: list[Field] = []): ...
    def integrate_traits(self): ...
    def __getitem__(self, key: Record) -> Record | None: ...
    def __setitem__(self, key: Record, value: Record): ...
    def __contains__(self, item: Record): ...
    # def upsert_field(self, field: Field): ...
    def add_record(self, record: Record): ...

class ListTable(Table):
    records: list[Record]
    # def __init__(self, *traits: Trait, fields: list[Field], name: str = None): ...
    def __getitem__(self, key: PyValue[int]): ...

class MetaTable(ListTable): ...
class BootstrapTable(ListTable):
    def __init__(self, name: str): ...

class DictTable(Table):
    records: dict[Record, Record]
    key_field: int
    def __init__(self, key_field: int = 0, *field_tuple, **fields): ...

class SetTable(Table):
    records: set[Record]
    # def __init__(self, *fields, name=None): ...

class VirtTable(SetTable):
    records = None
    # def __init__(self, *fields, name=None): ...

# class Slice(Table):
#     parent: Table
#     def __init__(self, parent: Table): ...
#
# class PredicateSlice(Slice, VirtTable):
#     predicate: Function | PyFunction
#     def __init__(self, parent: Table, predicate: Function | PyFunction): ...
#
# class VirtSlice(Slice, VirtTable): ...
#
# class ListSlice(Slice, ListTable): ...
#
# class DictSlice(Slice, DictTable): ...
#
# class SetSlice(Slice, SetTable): ...

class Field(Record):
    name: str
    type: Matcher = None
    def __init__(self, name: str,
                 type: Matcher = None,
                 default: Function | None = py_value(None),
                 formula: Function = py_value(None)): ...

    # def get_data(self, rec: Record, idx: int): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Slot(Field):
    default: Function | None  # default should be a function with a single option with a single parameter: self
    def __init__(self, name: str, type: Matcher, default: Function = None): ...
    # def get_data(self, rec: Record, idx: int): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Formula(Field):
    formula: Function
    def __init__(self, name: str, type: Matcher, formula: Function): ...
    # def get_data(self, rec: Record, idx: int): ...

class Setter(Field):
    fn: Function
    def __init__(self, name: str, fn: Function): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Matcher:
    name: str | None
    invert: int = 0
    guard: Function | PyFunction = None
    rank: tuple[int, int, ...]  # for sorting
    def __init__(self, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def issubset(self, other: Matcher) -> bool: ...
    def equivalent(self, other: Matcher) -> bool: ...
    def match_score(self, arg: Record) -> bool | float: ...
    def basic_score(self, arg) -> bool | float: ...
    def call_guard(self, arg: Record) -> bool: ...

class TableMatcher(Matcher):
    table: Table
    def __init__(self, table: Table, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class TraitMatcher(Matcher):
    trait: Trait
    def __init__(self, trait: Trait, name: str = None, guard: Function | PyFunction = None, inverse=False): ...

# class SliceMatcher(Matcher):
#     slices: tuple[Slice, ...]
#     def __init__(self, *slices: Slice, name=None, guard=None, inverse=False): ...
class ValueMatcher(Matcher):
    value: Record
    def __init__(self, value: Record, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class FieldMatcher(Matcher):
    fields: dict[str, Matcher]
    def __init__(self, fields: dict[str, Matcher], name=None, guard=None, inverse=False): ...

class FunctionMatcher(Matcher):
    pattern: Pattern
    return_type: Matcher
    def __init__(self, pattern: Pattern, return_type: Matcher, name=None, guard=None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class UnionMatcher(Matcher):
    matchers: frozenset[Matcher]
    # params: set[Parameter]  # this would make it more powerful, but not worth it for the added complexity
    # examples;
        # int+ | str
        # list[int] | int+
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Intersection(Matcher):
    matchers: frozenset[Matcher]
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class AnyMatcher(Matcher):
    def __eq__(self, other): ...
    def __hash__(self): ...

class Parameter:
    matcher: Matcher | None = None
    name: str | None
    quantifier: str  #  "+" | "*" | "?" | ""
    count: tuple[int, int | float]
    optional: bool
    multi: bool
    default: Option | None

    def __init__(self, matcher: Matcher | None, name: str = None, quantifier: str = "", default: Record | Option = None): ...
    def issubset(self, other: Parameter) -> bool: ...
    def try_get_matchers(self) -> tuple[Matcher, ...] | list[Matcher]: ...
    def compare_quantifier(self, other: Parameter) -> int: ...
    def match_score(self, value: Record) -> int | float: ...

class UnionParam(Parameter):
    parameters: tuple[Parameter, ...]
    def __init__(self, *parameters: Parameter, name: str = None, quantifier: str = ""): ...

class Pattern(Record):
    parameters: tuple[Parameter]
    named_params: dict[str, Parameter]
    def __init__(self, *parameters: Parameter, **named_params: Parameter): ...
    def to_args(self) -> Args | None: ...
    def match_score(self, *values: Record) -> int | float: ...
    def issubset(self, other: Pattern) -> bool: ...
    def min_len(self) -> int: ...
    def max_len(self) -> int | float: ...
    # def match_zip_recursive(self, state: MatchState) -> 0 | tuple[int|float, dict[str, Record]]: ...
    def match_zip(self, args: tuple[Record, ...] | Args = None) -> tuple[float|int, dict[str, Record]] | 0: ...
    def __len__(self): ...
    def __getitem__(self, item): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class MatchState:
    parameters: list[Parameter]
    args: list[Record]
    i_param: int
    i_arg: int
    score: int | float
    param_score: int | float
    bindings: dict[str, Record | list[Record]]
    def __init__(self, parameters, args: list[Record] | Args, i_param=0, i_arg=0, score=0, param_score=0, bindings=None): ...
    @property
    def success(self) -> int | float: ...
    @property
    def param(self) -> Parameter: ...
    @property
    def arg(self) -> Record: ...
    def branch(self, **kwargs) -> MatchState: ...
    def match_zip(self) -> (int | float, dict[str, Record | list[Record]]): ...
    def score_and_bindings(self) -> (int | float, dict[str, Record | list[Record]]): ...

# class SubPattern:
#     patterns: tuple[Pattern, ...]
#     def __init__(self, *patterns: Pattern): ...
#
# class UnionPattern(SubPattern): ...
#
# class IntersectionPattern(SubPattern): ...

def patternize(value: Record) -> Pattern: ...

class Args(Record):
    positional_arguments: list[Record] | tuple[Record]
    named_arguments: dict[str, Record]
    flags: set[str]
    def __init__(self, *args: Record, flags: set[str] = None, **kwargs: Record): ...
    def __len__(self): ...
    def __getitem__(self, item: int | str): ...
    def __iter__(self): ...
    def keys(self): ...
    def __add__(self, other: Args | tuple[Record] | set[str] | dict[str, Record]): ...
    def __radd__(self, other: Args | tuple[Record] | set[str] | dict[str, Record]): ...
    def __eq__(self, other): ...
    def dict(self) -> dict: ...
    def __hash__(self): ...
    def __repr__(self): ...


class CodeBlock:
    exprs: list[Expression]
    scope: Closure | None
    native: PyFunction
    def __init__(self, block: Block | PyFunction): ...
    def execute(self, args: tuple[Record, ...] = None,
                caller: Record = None,
                bindings: dict[str, Record] = None,
                *, fn: Function = None): ...

class Native(CodeBlock):
    fn: PyFunction  # fn must accept one argument of type Args
    def __init__(self, fn: PyFunction): ...


class Closure:
    # names: dict[str, Record]
    vars: dict[str, Record]
    locals: dict[str, Record]
    code_block: CodeBlock
    scope: Closure
    args: tuple[Record, ...]
    caller: Record
    fn: Function
    return_value: Record = None
    def __init__(self, code_block: CodeBlock | None,
                 args: tuple[Record, ...] = None,
                 caller: Record = None,
                 bindings: dict[str, Record] = None,
                 fn: Function = None): ...
    def assign(self, name: str, value: Record): ...

class TopNamespace(Closure):
    code_block = None
    scope = None
    args = None
    caller = None
    def __init__(self, bindings: dict[str, Record]): ...

opt_resolution = Record | CodeBlock | PyFunction | None
class Option(Record):
    # env: Closure
    pattern: Pattern
    resolution: opt_resolution
    value: Record
    block: CodeBlock
    fn: PyFunction
    alias: Option
    dot_option: bool
    return_type: Matcher
    def __init__(self, pattern: FlexiPatt, resolution: opt_resolution = None): ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def nullify(self): ...
    # def assign(self, val_or_block: opt_resolution): ...
    def set_resolution(self, resolution) -> None: ...
    def get_resolution(self) -> opt_resolution: ...
    def resolve(self, args: Args | tuple[Record, ...] = None, caller: Record = None, bindings: dict[str|int, Record] = None) \
            -> Record: ...


class Operator:
    text: str
    prefix: int | None
    postfix: int | None
    binop: int | None
    ternary: str | None
    associativity: str
    fn: Function
    chainable: bool
    static: bool | PyFunction
    def __init__(self, text, fn:Function=None, prefix:int=None, postfix:int=None, binop:int=None,
                 ternary:str=None, associativity='left', chainable:bool=False, static=False): ...
    def eval_args(self, lhs, rhs) -> list[Record]: ...
