import math
import types
from fractions import Fraction
from Env import *
from Syntax import Block, FunctionLiteral
from Expressions import Expression
from typing import TypeVar, Generic

FlexiPatt = Pattern | Parameter | Matcher | str
class FunctionRecordPrototype:
    name: str
    mro: tuple[Function, ...]
    env: Record
    caller: Function | None  # self
    options: list[Option]
    # named_options: dict[str, Option]
    hashed_options: dict[tuple[Record, ...], Option]
    args: list[Option]
    block: Block
    exec: any
    return_type: Pattern
    return_value: Record | None
    # value: val_types
    is_null: bool
    def add_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    def remove_option(self, pattern: FlexiPatt): ...
    def assign_option(self, pattern: Pattern, resolution: opt_resolution = None) -> Option: ...
    def index_of(self, key: list[Function]) -> int | None: ...
    def select_and_bind(self, key: list[Record] | tuple[Record], walk_prototype_chain=True, ascend_env=False) \
            -> tuple[Option, dict[str, Record]]: ...
    def select_by_pattern(self, patt, default=None, ascend_env=False) -> Option | None: ...
    def select_by_name(self, name: str, ascend_env=True) -> Option | None: ...
    def select_by_value(self, value: tuple[Record, ...], ascend_env=True) -> Option | None: ...
    def call(self, *key: Record, copy_option=True, ascend=False) -> Record: ...
    def deref(self, name: str, ascend_env=True) -> Function: ...
    def init(self, pattern: Pattern, key: list[Record], parent: Function = None, copy=True) -> Function: ...
    def instanceof(self, prototype: Function) -> float: ...
    def clone(self) -> Function: ...

class Record(FunctionRecordPrototype):
    table: Table
    data: list[Record]
    key: Record
    index: int | None
    def __init__(self, table: Table, **data: Record): ...
    def get(self, name: str): ...
    def get_by_index(self, index: int): ...
    def set(self, name: str, value: Record): ...
    def set_by_index(self, index: int, value: Record): ...
    def hashable(self) -> bool: ...


T = TypeVar('T')
class PyValue(Record, Generic[T]):
    value: T
    def __init__(self, table: Table, value: T): ...

# class PyValue(Record):
#     value: None | bool | int | Fraction | float | str | tuple | frozenset
#     def __init__(self, table: Table, value: None | bool | int | Fraction | float | str | tuple | frozenset): ...

def py_value(value: None | bool | int | Fraction | float | str | tuple | frozenset) -> PyValue: ...
def piliize(value: any) -> Record: ...


class Table(Record):
    fields: list[Field]
    field_ids: dict[str, int]
    option_field: int | None
    records: list[Record] | dict[Record, Record] | set[Record] | None
    def __init__(self, *field_tuple: Field, **fields: Matcher): ...
    def __getitem__(self, key: Record) -> Record | None: ...
    def __setitem__(self, key: Record, value: Record): ...
    def upsert_field(self, field: Field): ...
    def add_record(self, record=None, **data): ...
    def _add_record(self, record: Record): ...

class ListTable(Table):
    records: list[Record]
    def __init__(self, *field_tuple, **fields): ...
    def __getitem__(self, key: PyValue[int]): ...

class MetaTable(ListTable):
    def __init__(self): ...


class DictTable(Table):
    records: dict[Record, Record]
    key_field: int
    def __init__(self, key_field: int = 0, *field_tuple, **fields): ...

class SetTable(Table):
    records: set[Record]
    def __init__(self, *field_tuple, **fields): ...

class VirtTable(SetTable):
    records = None
    def __init__(self, *field_tuple, **fields): ...

class Slice(Table):
    parent: Table
    filter: Function | callable
    def __init__(self, parent: Table, filter: Function | callable): ...

class Field(Record):
    name: str
    type: Matcher
    setter: Function = None
    def __init__(self, name: str, type: Matcher, default: Function | None = py_value(None),
                 formula: Function = py_value(None), setter: Function = None): ...
    def deref(self, record: Record): ...

class Slot(Field):
    default: Function
    def __init__(self, name: str, type: Matcher, default: Function = None, setter: Function = None): ...

class Formula(Field):
    formula: Function
    def __init__(self, name: str, type: Matcher, formula: Function, setter: Function = None): ...

class Matcher:
    name: str | None
    inverse: bool = False
    guard: Function | callable = None
    def __init__(self, name: str = None, guard: Function | callable = None, inverse=False): ...
    def match_score(self, arg: Record) -> int | float: ...
    def call_guard(self, arg: Record) -> bool: ...

class TableMatcher(Matcher):
    table: Table
    def __init__(self, table: Table, name: str = None, guard: Function | callable = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class ValueMatcher(Matcher):
    value: Record
    def __init__(self, value: Record, name: str = None, guard: Function | callable = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Union(Matcher):
    monads: frozenset[Matcher]
    # params: set[Parameter]  # this would make it more powerful, but not worth it for the added complexity
    # examples;
        # int+ | str
        # list[int] | int+
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | callable = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Intersection(Matcher):
    monads: frozenset[Matcher]
    def __init__(self, *monads: Matcher, name: str = None, guard: Function | callable = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class AnyMatcher(Matcher):
    def __eq__(self, other): ...
    def __hash__(self): ...

class Parameter:
    type: Matcher
    quantifier: str  #  "+" | "*" | "?" | ""
    count: tuple[int, int | float]
    optional: bool
    multi: bool

    def __init__(self, type: Matcher, quantifier: str = ""): ...
    def match_score(self, value: Function) -> int | float: ...

class AnyParam(Parameter):
    pass

def copy_bindings(saves: dict[str, Function]) -> dict[str, Function]: ...

class Pattern(Record):
    parameters: tuple[Parameter]
    def __init__(self, *parameters: Parameter): ...
    def match_score(self, arg: Record) -> int | float: ...
    def min_len(self) -> int: ...
    def max_len(self) -> int | float: ...
    def match_zip_recursive(self, args: list = None, i_inst: int = 0, i_arg: int = 0, score: float = 0, sub_score: float = 0, saves: dict[str, Record] = None) \
            -> 0 | tuple[int|float, dict[str, Record]]: ...
    def match_zip(self, args: list[Record] = None) -> tuple[float|int, dict[str, Record]] | 0: ...
    def __len__(self): ...
    def __getitem__(self, item): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class SubPattern:
    patterns: tuple[Pattern, ...]
    def __init__(self, *patterns: Pattern): ...

class UnionPattern(SubPattern): ...

class IntersectionPattern(SubPattern): ...

def patternize(value: Record) -> Pattern: ...

class FuncBlock:
    exprs: list[Expression]
    env: Record
    native: callable
    def __init__(self, block: Block | FunctionLiteral | callable, env: Function = None): ...
    def make_function(self, options: dict[Pattern, opt_resolution], type: Function, caller: Function = None) -> Function: ...
    def execute(self, args: list[Function] = None, scope: Function = None, dot_option: bool = False) -> Function: ...

opt_resolution = Function | FuncBlock | callable | None
class Option(Record):
    pattern: Pattern
    resolution: opt_resolution
    value: Record
    block: FuncBlock
    fn: callable
    alias: Option
    dot_option: bool
    def __init__(self, pattern: FlexiPatt, resolution: opt_resolution = None): ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def nullify(self): ...
    def assign(self, val_or_block: opt_resolution): ...
    def resolve(self, args: tuple[Record, ...] = None, caller: FunctionRecordPrototype = None, bindings: dict[str|int, Record] = None) -> Record: ...

class Function(Record):
    def __init__(self,
                 options: dict[FlexiPatt, opt_resolution] = None,
                 args: dict[FlexiPatt, opt_resolution] = None,
                 type: Table = None,
                 env: Function = None,
                 # value: Value = None,
                 # is_null=False,
                 caller: Function = None,
                 name: str = None
                 ): ...

class Operator:
    text: str
    prefix: int | None
    postfix: int | None
    binop: int | None
    ternary: str | None
    associativity: str
    fn: Function
    chainable: bool
    static: bool | callable
    def __init__(self, text, fn:Function=None, prefix:int=None, postfix:int=None, binop:int=None,
                 ternary:str=None, associativity='left', chainable:bool=False, static=False): ...
    def eval_args(self, lhs, rhs) -> list[Record]: ...
