# from DataStructures import *
from tables import *
from fractions import Fraction
from operators import Operator

class Context:
    source_code: str
    line: int
    stack: list[Frame]
    env: Frame
    root: Frame
    debug: bool
    trace: list[Call]
    break_loop: int
    continue_: int
    settings: dict
    @staticmethod
    def push(line: int, env: Frame, option: Option = None): ...
    @staticmethod
    def _push(line: int, env: Frame, option: Option = None): ...
    @staticmethod
    def pop(): ...
    @staticmethod
    def get_trace() -> str: ...
    @classmethod
    def make_expr(cls, nodes): ...
    @staticmethod
    def deref(name: str, *default): ...

class Call:
    line: int
    fn: Function
    option: Option
    def __init__(self, line: int, fn: Function, option: Option = None): ...
    def __str__(self): ...

class PiliException(Exception): ...
class RuntimeErr(PiliException): ...
class SyntaxErr(PiliException): ...
class KeyErr(RuntimeErr): ...
class NoMatchingOptionError(KeyErr): ...
class MissingNameErr(KeyErr): ...
class InitializationErr(KeyErr): ...
class OperatorErr(SyntaxErr): ...
class PatternErr(RuntimeErr): ...
class TypeErr(PatternErr): ...
class MatchErr(PatternErr): ...
class SlotErr(TypeErr): ...

Op: dict[str, Operator]
BuiltIns: dict[str, Function | Pattern | PyFunction]
TypeMap: dict[type, Function]

def read_number(text: str, base=6) -> int | float | Fraction: ...
def write_number(num: int|float|Fraction, base=6, precision=12, sep="_") -> str: ...

def call(fn: PyFunction, args: Args): ...


class BindTarget:
    def bind(self, value: Record): ...


class BindTargetName(BindTarget):
    name: str
    scope: Frame
    def __init__(self, name: str, scope: Frame = None): ...


class BindTargetKey(BindTarget):
    key: Record
    fn: Function
    def __init__(self, key: Record, fn: Function): ...