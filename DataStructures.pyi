from Syntax import BasicType, Block, Node

class Context:
    line: int
    _env: list[Function]
    env: Function
    root: Function
    @staticmethod
    def push(env: Function): ...
    @staticmethod
    def pop(): ...

    @classmethod
    def make_expr(cls, nodes):
        pass


val_types = None | bool | int | float | str | Function | Pattern | BasicType | list[Value]

class Value:
    value: val_types
    type: BasicType
    def __init__(self, value: val_types, basic_type: BasicType = None): ...
    def set_value(self, new_value: Value | val_types) -> Value: ...
    def set_type(self, basic_type: BasicType = None) -> BasicType: ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def clone(self) -> Value: ...

class Parameter:
    name: str | None
    value: Value | None
    base_types: frozenset[BasicType]
    fn: Function    # (any) -> bool
    def __init__(self, name: str = None, value: Value = None, basic_type: BasicType | tuple[BasicType, ...] | frozenset[BasicType] = None, fn: callable = None): ...
    def specificity(self) -> int: ...

# score is out 7560, this number is 3*2520 (the smallest int divisible by all integers up to 10)
def match_score(val: Value, param: Parameter) -> int: ...

class Pattern:
    """
    A Pattern is like a regex for types and parameters; it can match one very specific type, or even
    one specific value or it can match a type on certain conditions (eg int>0), or union of types
    """
    required_parameters: tuple[Parameter,]
    optional_parameters: tuple[Parameter,]
    specificity: int
    def __init__(self, *required_params: Parameter, optional_parameters: tuple[Parameter,] = None): ...
    @property
    def all_parameters(self) -> tuple[Parameter, ]: ...
    def zip(self, args: list[Value]) -> dict[Parameter, Value]: ...
    def __len__(self): ...
    def __getitem__(self, item): ...

def make_expr(nodes: list[Node]) -> Expression: ...

opt_value_type = Value | Block | callable | None

class Option:
    pattern: Pattern
    value: Value
    block: Block
    fn: callable
    def __init__(self, pattern: Pattern | Parameter | str, value: opt_value_type = None): ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def assign(self, val_or_block: Value | Block): ...
    def execute(self, args: list[Value], proto: Function = None, env: Function = Context.env) -> Value: ...

class RuntimeErr(Exception): ...
class SyntaxErr(Exception): ...
class NoMatchingOptionError(RuntimeErr): ...
class OperatorError(SyntaxErr): ...

class Function:
    prototype: Function # class-like inheritance
    args: list[Value]
    options: list[Option]
    named_options: dict[str, Option]
    block: Block
    env: Function
    exec: any
    return_value: Value
    is_null: bool
    init: any
    def __init__(self, opt_pattern: Pattern | Parameter | str = None,
                     opt_value: opt_value_type = None,
                     options: dict[Pattern | Parameter | str, opt_value_type] = None,
                     # block: Block = None,
                     prototype: Function = None,
                     env: Function = Context.env,
                     # value: Value = None,
                     # is_null=False
                 ): ...

    def add_option(self, pattern: Pattern | Parameter | str, value: opt_value_type = None) -> Option: ...
    def assign_option(self, pattern: Pattern, value: opt_value_type = None) -> Function: ...
    def index_of(self, key: list[Value]) -> int | None: ...
    def select(self, key: Pattern | list[Value], walk_prototype_chain=True, ascend_env=False) -> Option: ...
    def call(self, key: list[Value], copy_option=True, ascend=False) -> Value: ...
    def deref(self, name: str, ascend_env=True) -> Value: ...
    def execute(self) -> Value: ...
    def init(self, pattern: Pattern, key: list[Value], parent: Function = None, copy=True) -> Function: ...
    def clone(self) -> Function: ...

def name_patt(name: str) -> Pattern: ...

class Native(Function):
    fn: callable
    def __init__(self, fn: callable): ...
    def execute(self) -> Value: ...
    def init(self, pattern: Pattern, key: list[Value], parent: Function = None, copy=True) -> Native: ...

def NullFunction() -> Function: ...

Op: dict[str, Operator]
BuiltIns: dict[str, Function]

class Operator:
    text: str
    prefix: int
    postfix: int
    binop: int
    ternary: str
    associativity: str
    fn: Function
    static: bool | callable
    def __init__(self, text, fn:Function=None, prefix:int=None, postfix:int=None, binop:int=None,
                 ternary:str=None, associativity='left', static=False): ...
    def prepare_args(self, lhs, mid, rhs) -> list[Value]: ...
